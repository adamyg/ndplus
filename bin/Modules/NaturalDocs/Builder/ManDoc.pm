###############################################################################
#
#   Package: NaturalDocs::Builder::ManDoc
#
###############################################################################
#
#   A package that generates output in MANDOC format.
#   The mandoc UNIX manpage compiler toolset, see ttp://mdocml.bsd.lv/
#
#   All functions are called with Package->Function() notation.
#
###############################################################################

# This file is part of Natural Docs, which is Copyright (C) 2003-2008 Greg Valure
# Copyright (C) 2014-2022 Adam Young
# Natural Docs is licensed under the GPL

use Tie::RefHash;
use strict;

package NaturalDocs::Builder::ManDoc;

use NaturalDocs::Builder::ManTable;
use NaturalDocs::Builder::ManWrap;

use base 'NaturalDocs::Builder::Base';

#   Constants: NDMarkupToMAN Styles
#       These are the styles used with <NDMarkupToMAN()>.
#
#   NDMARKUPTOMAN_GENERAL - General style.
#   NDMARKUPTOMAN_SUMMARY - For summaries.
#   NDMARKUPTOMAN_TOOLTIP - For tooltips.
#
use constant NDMARKUPTOMAN_GENERAL  => undef;
use constant NDMARKUPTOMAN_SUMMARY  => 1;
use constant NDMARKUPTOMAN_TOOLTIP  => 2;

#
#   constant: ADD_HIDDEN_BREAKS
#
#   Just a synonym for "1" so that setting the flag on <StringToMAN()> is clearer in the calling code.
#
use constant ADD_HIDDEN_BREAKS      => 1;

#   Hash: abbreviations
#       An existence hash of acceptable abbreviations.  These are words that <AddDoubleSpaces()> won't put a second space
#       after when followed by period-whitespace-capital letter.  Yes, this is seriously over-engineered.
#
my %abbreviations = ( mr => 1, mrs => 1, ms => 1, dr => 1,
                        rev => 1, fr => 1, 'i.e' => 1,
                        maj => 1, gen => 1, pres => 1, sen => 1, rep => 1,
                        n => 1, s => 1, e => 1, w => 1, ne => 1, se => 1, nw => 1, sw => 1 );

my @monthnames = (
        "January",      "February",     "March",
        "April",        "May",          "June",
        "July",         "August",       "September",
        "October",      "November",     "December"
        );


###############################################################################
#   Group: Implemented Interface Functions

#   Function: INIT
#       Registers the package with <NaturalDocs::Builder>.
#
sub INIT
    {
    NaturalDocs::Builder->Add(__PACKAGE__);
    };


#   Function: CommandLineOption
#       Returns the option to follow -o to use this package.  In this case, "html".
#
sub CommandLineOption
    {
    return 'ManDoc';
    };


#   Function: BuildFile
#       Builds the output file from the parsed source file.
#
#   Parameters:
#       file - <ParseFile> object of the parsed file.
#
sub BuildFile #(file)
    {
    my ($self, $file) = @_;

    my $sourceFile = $file->Source();
    my $outputFile = $self->OutputFileOf($sourceFile);

    if (!open(OUTPUTFILEHANDLE, '>' . $outputFile))
        {
        NaturalDocs::File->CreatePath( NaturalDocs::File->NoFileName($outputFile) );

        open(OUTPUTFILEHANDLE, '>' . $outputFile)
            or die "Couldn't create output file " . $outputFile . "\n";
        };

    binmode OUTPUTFILEHANDLE;                           # disable \n conversion

    print OUTPUTFILEHANDLE
        '.\"' . "\n" .
        '.\" mandoc, generated by ND+' . "\n" .
        '.\"' . "\n" .
        ".Dd ". $self->BuildDate() . "\n" .
        '.Dt "'. $self->BuildTitle($sourceFile) . "\" 1\n" .
        '.Os' . "\n" .
            $self->BuildContent($file)
        ;

    close(OUTPUTFILEHANDLE);
    }


#   Function: BuildDate
#       Builds a MANDOC formatted version of the current date.
#
#   Parameters:
#       none
#
sub BuildDate()         #()
    {
    my ($sec, $min, $hour, $mday, $mon, $year) =
            localtime(time);

                                                        # Month Day Year
    return sprintf("%s %d %04d", $monthnames[$mon], $mday, $year + 1900);
    }


#   Function: BuildIndex
#       Builds an index for the passed type.
#
#   Parameters:
#       type            - The <TopicType> to limit the index to, or undef if none.
#
sub BuildIndex          #(type)
    {
##TODO
    my ($self, $type) = @_;
    }


#   Function: UpdateMenu
#       Updates the menu in all the output files that weren't rebuilt.  Also generates index.mandoc.
#
sub UpdateMenu
    {
##TODO
    my $self = shift;
    }


###############################################################################
#
#   Function: BuildContent
#       Builds and returns the main page content.
#
#   Parameters:
#       file            - <ParseFile> object of the parsed file.
#
#   Returns:
#       The page content in MANDOC markup.
#
sub BuildContent        #(file)
    {
    my ($self, $file) = @_;

    my $sourceFile = $file->Source();                   # source <FileName>.
    my $parsedFile = $file->Topics();                   # parser results, arrayref of <NaturalDocs::Parser::ParsedTopic> objects.

    my $output = '.\" <div id=Content>'."\n";
    my $lastTopicType = '';
    my $imgSeq = 0;                                     # image/ditaa
    my $i = 0;

    while ($i < scalar @$parsedFile)
        {
        my $topic = $parsedFile->[$i];

        if ($topic->Summaries() == ::SUMMARIES_ONLY())
            {                                           # package/summaries
            $i++;
            next;
            }

        my $topicType = $topic->Type();
        my $nameoftype = NaturalDocs::Topics->NameOfType($topicType, 0, 1);
        my $anchor = $self->SymbolToMANSymbol($topic->Symbol());
        my $scope = NaturalDocs::Topics->TypeInfo($topicType)->Scope();

        my $summary;
        my $hierarchy;
        my $prototype = $topic->Prototype();
        my $body = $topic->Body();
        my $hasBreak = 0;

        $output .=                                      # embedded comment; permits post-processing
            '.\" START:type=' . $topicType .
                "\tanchor="  . $self->RestoreAmpChars($anchor) .
                "\ttitle="   . $self->RestoreAmpChars($topic->Title()) .
                "\tsummary=" . $self->RestoreAmpChars($topic->Summary()) .
                "\n";

        $body = undef                                   # empty body
            if (defined $body && !$body);

        if ($i == 0 || $scope == ::SCOPE_START() || $scope == ::SCOPE_END())
            {
            $summary = $self->BuildSummary($sourceFile, $parsedFile, $i);
            };

        if ($i == 0)                                    # MANDOC requirement, unconditional opening section
            {
            $output .=
                '.Sh NAME' . "\n" .
                    $self->RestoreAmpChars($topic->Title()) .
                "\n";
            }
        elsif ($scope == ::SCOPE_START() || $scope == ::SCOPE_END())
            {
        ##  $output .=
        ##      '.Sh Section: ' . $self->RestoreAmpChars($topic->Title()) . "\n";

            $output .=
                '.TS' . "\n" .
                'l.'  . "\n" .
                '\fB[[ ' . $self->RestoreAmpChars($topic->Title()) . ' ]]\fR' . "\n" .
                '\fB' . ("_" x 60) . '\fR' . "\n" .
                "\n"  .
                '.TE' . "\n" .
                '.Pp' . "\n";
            }
        elsif ($topicType eq ::TOPIC_GROUP())
            {
        ##  $output .=
        ##      '.Sh Group: ' . $self->RestoreAmpChars($topic->Title()) . "\n";

            $output .=
                '.TS' . "\n" .
                'l.'  . "\n" .
                '\fB<< ' . $self->RestoreAmpChars($topic->Title()) . ' >>\fR' . "\n" .
                '\fB' . ("_" x 60) . '\fR' . "\n" .
                "\n"  .
                '.TE' . "\n" .
                '.Pp' . "\n";
            }
        else
            {
            $nameoftype = 'Topic'                       # generic topic
                if ($topicType eq ::TOPIC_GENERIC());
            $nameoftype = ucfirst(lc($nameoftype));

            $output .=
                '.Dl ' . ("_" x 30) . "\n"
                    if ($lastTopicType ne ::TOPIC_GROUP());

            $output .=
                '.Sh ' . $nameoftype . ': ' . $self->RestoreAmpChars($topic->Title()) . "\n";
            };

        $lastTopicType = $topicType;

    ##TODO
    ##  if (NaturalDocs::Topics->TypeInfo($topic->Type() )->ClassHierarchy())
    ##      {
    ##      $hierarchy = $self->BuildClassHierarchy($sourceFile, $topic->Symbol());
    ##      };

        if ($i == 0)
            {                                           # opening section, break NAME
            if (defined $summary && defined $body)
                {
                $output .= ".Ss Summary\n";
                }
            elsif (defined $hierarchy || defined $prototype || defined $body)
                {
                $output .= ".Ss Introduction\n";
                }
            };

    ##TODO
    ##  if (defined $hierarchy)
    ##      {
    ##      $output .= $hierarchy;
    ##      ++$hasBreak;
    ##      }

        if (defined $prototype)
            {                                           # prototype block
            $output .=
                '.\" START:prototype=' . $self->CompressWS($prototype) . "\n";
            $output .= $self->BuildPrototype($topic->Type(), $prototype, $sourceFile, $file);
            $output .=
                '.\" END:prototype' . "\n";
            ++$hasBreak;
            }
        elsif ($topicType ne ::TOPIC_GENERIC() && $topicType ne ::TOPIC_GROUP())
            {                                           # empty prototype block
            $output .=
                '.\" START-END:prototype' . "\n";
            };

        if (defined $body)
            {
            $output .= $self->NDMarkupToMAN($sourceFile, $body, $topic->Symbol(),
                                    $topic->Package(), $topic->Type(), $topic->Using(), undef, \$imgSeq);
            ++$hasBreak;
            };

        if ($summary)
            {
            $output .= $summary;
            ++$hasBreak;
            };

        if ($scope == ::SCOPE_START() || $scope == ::SCOPE_END() || !$hasBreak)
            {
            $output .= "\e.Pp\e";
            };

        $output .=
            '.\" END:type=' . $topicType .
                "\tanchor=" . $self->RestoreAmpChars($anchor) .
                "\n";

        $i++;
        };

    $output .= '.\" !--Content--'."\n";

    # collapse paragraph breaks
    $output =~ s/\e\.Pp[\e\n]+\.Pp/\e.Pp/g;
    $output =~ s/\e\.Pp[\e\n]+\.Sh/\e.Sh/g;
    $output =~ s/\e\.Pp[\e\n]+\.Ss/\e.Ss/g;
    $output =~ s/\e\.Pp[\e\n]+\.Bl/\e.Bl/g;
    $output =~ s/\e\.Pp[\e\n]+\.Bd/\e.Bd/g;
    $output =~ s/\e\.Pp[\e\n]+\.It/\e.It/g;

    # blank lines
    $output =~ s/[\n\e]+/\e/g;

    # trailing white-space (tabs must be preserved)
    $output =~ s/[ ]+\e/\e/g;

    # finally replace command breaks with nl
    $output =~ s/\e/\n/g;

    return $output;
    };


#   Function: BuildPrototype
#       Builds and returns the prototype as MANDOC.
#
#   Parameters:
#       type            - The <TopicType> the prototype is from.
#       prototype       - The prototype to format.
#       sourceFile      - The <FileName> of the source.
#       file            - <ParseFile> object of the parsed file, if available.
#
#   Returns:
#       The prototype in MANDOC.
#
sub BuildPrototype      #(type, prototype, sourceFile, file)
    {
    my ($self, $type, $prototype, $sourceFile, $file) = @_;

    my $language =                                      # package/mode-line
        (defined $file ? $file->Language() : NaturalDocs::Languages->LanguageOf($sourceFile));

    if ($file && $language->Name() eq 'Text File')
        {                                               # mode-line
        my $languageModeline = $file->Modeline('lang');
        if ($languageModeline)
            {
            my $t_language = NaturalDocs::Languages->LanguageInstance($languageModeline);
            if ($t_language)                            # language override
                {
                $language = $t_language;
                }
            };
        };

    my $prototypeObject = $language->ParsePrototype($type, $prototype);
    my $output;

    if ($prototypeObject->OnlyBeforeParameters())
        {
        $output =
            "\e.TS\e" .
            "l.\e" .
            "_\e" .
                $self->ConvertAmpChars($prototypeObject->BeforeParameters()) . "\e" .
            "_\e" .
            ".TE\e" .
            ".Pp\e";
        $output =~ s/\s+/ /g;
        }
    else
        {                                               # none or more parameters
        my $params       = $prototypeObject->Parameters();
        my $beforeParams = $prototypeObject->BeforeParameters();
        my $afterParams  = $prototypeObject->AfterParameters();

        # Determine what features the prototype has and its length.

        my ($hasType, $hasTypePrefix, $hasNamePrefix, $hasDefaultValue, $hasDefaultValuePrefix);

        foreach my $param (@$params)
            {
            if ($param->Type())
                {
                $hasType = 1;
                };
            if ($param->TypePrefix())
                {
                $hasTypePrefix = 1;
                };
            if ($param->NamePrefix())
                {
                $hasNamePrefix = 1;
                };
            if ($param->DefaultValue())
                {
                $hasDefaultValue = 1;
                };
            if ($param->DefaultValuePrefix())
                {
                $hasDefaultValuePrefix = 1;
                };
            };

        $output =
            "\e.TS\n";

            # layout.
            $output .= "l";
            if ($language->TypeBeforeParameter()) {
                $output .= " l" if ($hasType);
                $output .= " l" if ($hasTypePrefix);
                $output .= " l" if ($hasNamePrefix);
                $output .= " l";
            } else {
                $output .= " l" if ($hasType || $hasTypePrefix);
            }
            $output .= " l" if ($hasDefaultValue);
            $output .= " l" if ($hasDefaultValuePrefix);

        $output .=
            ".\n" .
            "_";

            # data.
            for (my $i = 0; $i < scalar @$params; $i++)
                {
                if (0 == $i)
                    {
                    $beforeParams =~ s/\s+/ /g;
                    $output .=
                        "\n" . $self->ConvertAmpChars($beforeParams) . "\t";
                    }
                else
                    {
                    $output .=
                        "\n\t";
                    };

                if ($language->TypeBeforeParameter())
                    {
                    if ($hasTypePrefix)
                        {
                        my $tmp = $self->ConvertAmpChars($params->[$i]->TypePrefix());
                        $tmp =~ s/\s+/ /g;
                        $output .=
                            $tmp . "\t";
                        };

                    if ($hasType)
                        {
                        my $tmp = $self->ConvertAmpChars($params->[$i]->Type());
                        $tmp =~ s/\s+/ /g;
                        $output .=
                            $tmp . "|\t";
                        };

                    if ($hasNamePrefix)
                        {
                        my $tmp = $self->ConvertAmpChars($params->[$i]->NamePrefix());
                        $tmp =~ s/\s+/ /g;
                        $output .=
                            $tmp . "\t";
                        };

                    my $name = $self->ConvertAmpChars($params->[$i]->Name());
                    $name =~ s/\s+/ /g;
                    $output .=
                        $name . "\t";
                    }

                else    #!$language->TypeBeforeParameter()
                    {
                    my $name = $self->ConvertAmpChars($params->[$i]->NamePrefix() . $params->[$i]->Name());
                    $name =~ s/\s+/ /g;
                    $output .=
                        " \t" . $name . "\t";

                    if ($hasType || $hasTypePrefix)
                        {
                        my $tmp = $self->ConvertAmpChars($params->[$i]->TypePrefix());
                        $tmp .= ' ' if ($tmp);
                        $tmp .= $self->ConvertAmpChars($params->[$i]->Type());
                        $tmp =~ s/\s+/ /g;
                        $output .=
                            $tmp;
                        };
                    };

                if ($hasDefaultValuePrefix)
                    {
                    my $tmp = $self->ConvertAmpChars($params->[$i]->DefaultValuePrefix());
                    $tmp =~ s/\s+/ /g;
                    $output .=
                        $tmp . "\t";
                    };

                if ($hasDefaultValue)
                    {
                    my $tmp = $self->ConvertAmpChars($params->[$i]->DefaultValue());
                    $tmp =~ s/\s+/ /g;
                    $output .=
                        $tmp . "\t";
                    };

                $output =~ s/\t$//;                     # remove trailing delimiter
                };

            $output .= ' ' . $self->ConvertAmpChars($afterParams);

        $output .=
            "\n_\n" .
            "\n.TE" .
            "\n.Pp\e";
        };

    return $output;
    };


#   Function: BuildClassHierarchy
#       Builds and returns a class hierarchy diagram for the passed class, if applicable.
#
#   Parameters:
#       sourceFile      - The source <FileName>.
#       class           - The class <SymbolString> to build the hierarchy of.
#

##TODO
sub BuildClassHierarchy #(sourceFile, symbol)
    {
    my ($self, $sourceFile, $symbol) = @_;

    my @parents = NaturalDocs::ClassHierarchy->ParentsOf($symbol);
    @parents = sort { ::StringCompare($a, $b) } @parents;

    my @children = NaturalDocs::ClassHierarchy->ChildrenOf($symbol);
    @children = sort { ::StringCompare($a, $b) } @children;

                                                        # package
    # Don't generate a call hierarchy, if the class
    #
    #   A) has not been defined (ie does not have a body),
    #   B) is an orphan (ie no children or parents) and the current
    #       page contains the definition (ie has a body).
    #
    my $target = NaturalDocs::SymbolTable->Lookup($symbol, $sourceFile);

    if (!defined $target ||
            (!scalar @parents && !scalar @children && ($target->File() eq $sourceFile)))
        {  return undef;  };


    my $output =
    '<div class=ClassHierarchy>';

    if (scalar @parents)
        {
        $output .='<table border=0 cellspacing=0 cellpadding=0><tr><td>';

        foreach my $parent (@parents)
            {
            $output .= $self->BuildClassHierarchyEntry($sourceFile, $parent, 'CHParent', 1);
            };

        $output .= '</td></tr></table><div class=CHIndent>';
        };

                                                        # package
    my $link = ($target->File() eq $sourceFile ? undef : 1);

    $output .=
    '<table border=0 cellspacing=0 cellpadding=0><tr><td>'
        . $self->BuildClassHierarchyEntry($sourceFile, $symbol, 'CHCurrent', undef)
    . '</td></tr></table>';

    if (scalar @children)
        {
        $output .=
        '<div class=CHIndent>'
            . '<table border=0 cellspacing=0 cellpadding=0><tr><td>';

        if (scalar @children <= 5)
            {
            for (my $i = 0; $i < scalar @children; $i++)
                {  $output .= $self->BuildClassHierarchyEntry($sourceFile, $children[$i], 'CHChild', 1);  };
            }
        else
            {
            for (my $i = 0; $i < 4; $i++)
                {  $output .= $self->BuildClassHierarchyEntry($sourceFile, $children[$i], 'CHChild', 1);  };

           $output .= '<div class=CHChildNote><div class=CHEntry>' . (scalar @children - 4) . ' other children</div></div>';
            };

        $output .=
        '</td></tr></table>'
        . '</div>';
        };

    if (scalar @parents)
        {  $output .= '</div>';  };

    $output .=
    '</div>';

    return $output;
    };


#   Function: BuildClassHierarchyEntry
#       Builds and returns a single class hierarchy entry.
#
#   Parameters:
#       sourceFile      - The source <FileName>.
#       symbol          - The class <SymbolString> whose entry is getting built.
#       style           - The style to apply to the entry, such as <CHParent>.
#       link            - Whether to build a link for this class or not.  When building the selected class' entry,
#                           this should be false.  It will automatically handle whether the symbol is defined or not.
#

##TODO
sub BuildClassHierarchyEntry #(sourceFile, symbol, style, link)
    {
    my ($self, $sourceFile, $symbol, $style, $link) = @_;

    my @identifiers = NaturalDocs::SymbolString->IdentifiersOf($symbol);
    my $name = join(NaturalDocs::Languages->LanguageOf($sourceFile)->PackageSeparator(), @identifiers);
    $name = $self->StringToMAN($name);

    my $output = '<div class=' . $style . '><div class=CHEntry>';

    if ($link)
        {
        my $target = NaturalDocs::SymbolTable->Lookup($symbol, $sourceFile);

        if (defined $target)
            {
            my $targetFile;

            if ($target->File() ne $sourceFile)
                {  $targetFile = $self->MakeRelativeURL( $self->OutputFileOf($sourceFile), $self->OutputFileOf($target->File()), 1 );  };
            # else leave it undef

            my $targetTooltipID = $self->BuildToolTip($symbol, $target->File(), $target->Type(),
                                                                          $target->Prototype(), $target->Summary());

            my $toolTipProperties = $self->BuildToolTipLinkProperties($targetTooltipID);

            $output .= '<a href="' . $targetFile . '#' . $self->SymbolToMANSymbol($symbol) . '" '
                            . 'class=L' . NaturalDocs::Topics->NameOfType($target->Type(), 0, 1) . ' ' . $toolTipProperties . '>'
                            . $name . '</a>';
            }
        else
            {  $output .= $name;  };
        }
    else
        {  $output .= $name;  };

    $output .= '</div></div>';
    return $output;
    };


#   Function: BuildSummary
#       Builds a summary, either for the entire file or the current class/section.
#
#   Parameters:
#       sourceFile      - The source <FileName> the summary appears in.
#       parsedFile      - A reference to the parsed source file.
#       index           - The index into the parsed file to start at.  If undef or zero, it builds a summary for the
#                           entire file.  If it's the index of a <TopicType> that starts or ends a scope, it builds
#                           a summary for that scope.
#
#   Returns:
#       The summary in MANDOC.
#
sub BuildSummary        #(sourceFile, parsedFile, index)
    {
    my ($self, $sourceFile, $parsedFile, $index) = @_;
    my $completeSummary;

    if (!defined $index || $index == 0)
        {
        $index = 0;
        $completeSummary = 1;
        }
    else
        {
        # Skip the scope entry.
        $index++;
        };

    my $indent = 0;
    my $blIndent = 0;
    my $inGroup;

    my $items = 0;                                      # summary
    my $outputFile = $self->OutputFileOf($sourceFile);
    my $output = '';

    $output .=
        '.\" <!--START_ND_SUMMARY-->'."\n";

        # Not all browsers get table padding right, so we need a div to apply the border.

        while ($index < scalar @$parsedFile)
            {
            my $topic = $parsedFile->[$index];
            my $scope = NaturalDocs::Topics->TypeInfo($topic->Type())->Scope();

            if (!$completeSummary && ($scope == ::SCOPE_START() || $scope == ::SCOPE_END()) )
                {  last;  };

            # Remove modifiers as appropriate for the current entry.

            if ($scope == ::SCOPE_START() || $scope == ::SCOPE_END())
                {
                $indent = 0;
                $inGroup = 0;
                }
            elsif ($topic->Type() eq ::TOPIC_GROUP())
                {
                if ($inGroup)
                    {  $indent--;  };
                $inGroup = 0;
                };

            if ((my $summaries = $topic->Summaries()))
                {                                       # package/summaries
                if ($summaries == ::SUMMARIES_ONLY())
                    {  $items = -1; }                   # force generation
                elsif ($items != -1 && $indent)
                    {  $items++;  }
                }

            if ($indent > $blIndent)
                {  $output .= "\e.Bl -column 1i " . (6.0 - (1 * $indent)) . "i\e";  }
            elsif ($indent < $blIndent)
                {  $output .= "\e.El\e";  }
            $blIndent = $indent;

            $output .=
                "\e.\\\" index=$index, indent=$indent, scope=$scope\e";

            # Add the entry itself.

            if ($indent >= 1) {
                $output .=
                    "\e.It " .
                        '"' . $self->RestoreAmpChars($topic->Title(), ADD_HIDDEN_BREAKS) . '"' .
                    "\t\"";
            } else {
                $output .=
                    "\e.Ss ".$self->StringToMAN($topic->Title(), ADD_HIDDEN_BREAKS) . "\e";
            }

            if ($index > 0)                             # ignore opening.
                {
                if (defined $topic->Body() || $topic->Summaries() == ::SUMMARIES_ONLY())
                    {                                   # package/summaries
                    $output .= $self->NDMarkupToMAN($sourceFile, $parsedFile->[$index]->Summary(),
                                        $parsedFile->[$index]->Symbol(), $parsedFile->[$index]->Package(),
                                        $parsedFile->[$index]->Type(), $parsedFile->[$index]->Using(),
                                        NDMARKUPTOMAN_SUMMARY);
                    };
                }

            $output .=
                ($indent >= 1 ? "\"" : "\e.Pp\e");

            # Prepare the modifiers for the next entry.

            if ($scope == ::SCOPE_START() || $scope == ::SCOPE_END())
                {
                $indent = 1;
                $inGroup = 0;
                }
            elsif ($topic->Type() eq ::TOPIC_GROUP())
                {
                if (!$inGroup && $index)
                    {
                    $indent++;
                    $inGroup = 1;
                    };
                };

            $index++;
            };

        while ($blIndent-- > 0)
            {  $output .= "\e.El\e";  }

    $output .=
        '.\" <!--END_ND_SUMMARY-->'."\n";

    # Return nothing if there's only one entry. #ND+, simple entries
    if ($items != -1 && $items < 2)
        {  return undef;  }

    return $output;
    };


#   Function: NDMarkupToMAN
#       Converts a block of <NDMarkup> to MANDOC.
#
#   Parameters:
#       sourceFile      - The source <FileName> the <NDMarkup> appears in.
#       text            - The <NDMarkup> text to convert.
#       symbol          - The topic <SymbolString> the <NDMarkup> appears in.
#       package         - The package <SymbolString> the <NDMarkup> appears in.
#       type            - The <TopicType> the <NDMarkup> appears in.
#       using           - An arrayref of scope <SymbolStrings> the <NDMarkup> also has access to, or undef if none.
#       style           - Set to one of the <NDMarkupToMAN Styles> or leave undef for general.
#       imgSeqRef       - Reference to Image sequence number variable.
#
#   Returns:
#       The text in MAN.
#
sub NDMarkupToMAN       #(sourceFile, text, symbol, package, type, using, style, imgSeqRef)
    {
    my ($self, $sourceFile, $text, $symbol, $package, $type, $using, $style, $imgSeqRef) = @_;

    my $sourceLanguage = NaturalDocs::Languages->LanguageOf($sourceFile);
    my $highlightMode  = NaturalDocs::Settings->HighlightMode();
    my $highlightLang  = '';
    my $dlSymbolBehavior;

    if ($type == ::TOPIC_ENUMERATION())
        {  $dlSymbolBehavior = $sourceLanguage->EnumValues();  }
    elsif (NaturalDocs::Topics->TypeInfo($type)->Scope() == ::SCOPE_ALWAYS_GLOBAL())
        {  $dlSymbolBehavior = ::ENUM_GLOBAL();  }
    else
        {  $dlSymbolBehavior = ::ENUM_UNDER_PARENT();  };

    my $inCode;                                         # inside a code block
    my $inDrawing;                                      # inside a draw block
    my $output;                                         # output buffer

    my @splitText =                                     # quote
        split(/(<\/?(?:drawing|code|prefixcode|quote)[^>]*>)/, $text);

    if ($highlightMode >= 2)
        {                                               # lower case, remove all blanks
        $highlightLang = lc($sourceLanguage->Name());
        $highlightLang =~ s/\s*//g;
        }

    while (scalar @splitText)
        {
        $text = shift @splitText;

        if ($text =~ /^<code([^>]*)>$/ || $text eq '<prefixcode>' || $text eq '<quote>')
            {
            $inCode = 1;
            }
        elsif ($text eq '</code>' || $text eq '</prefixcode>' || $text eq '</quote>')
            {
            $output .= "\e.Ed\e.Pp\e"
                if (2 == $inCode);
            $inCode = undef;
            }
        elsif ($inCode)
            {
            my $code = $self->RestoreAmpChars($text);

            if (1 == $inCode)
                {
                my $maxlen = 0;
                foreach (split("<br>|[\n\e]", $text))
                    {
                    $maxlen = length($_)
                        if (length($_) > $maxlen);
                    }
                $output .=
                    ($maxlen > 72 ?
                        "\e.Bd -literal \"x\"\e" :
                        ($maxlen > 68 ?
                            "\e.Bd -literal \"xx\"\e" : "\e.Bd -literal -offset \"xxxx\"\e"));
                $inCode  = 2;
                }
            $code =~ s/\\/\\(rs/g;
            $output .= $code;
            }
        elsif ($text =~ /^<drawing([^>]*)>$/)
            {
            $inDrawing = 1;
            }
        elsif ($text eq '</drawing>')
            {
            $inDrawing = undef;
            }
        elsif ($inDrawing)
            {                                           # svg images
            $output .= "\e.Bd -literal -offset \"svg\"\e";
            $output .= $text;
            $output .= "\e.Ed\e.Pp\e";
            }
        else
            {
            # Format non-code text.

            # Convert embedded newlines
            # these shall be compressed and restored on completion.
            $text =~ s/\n/\e/g;                         # newlines

            # Links and images
            $text =~ s/<link target=\"[^\"]*\" name=\"([^\"]*)\" original=\"[^\"]*\">/&lt;$1&gt;/g;
            $text =~ s/<url target=\"[^\"]*\" name=\"([^\"]*)\">/$self->BuildURLLink($1, $2)/ge;
            $text =~ s{<img mode="([^\"]*)" target="([^\"]*)" original="([^\"]*)">}
                            {$self->BuildImage($sourceFile, $1, $2, $3, $imgSeqRef)}ge;

            $text =~ s/([(]?see): /$1:\\~/gi;           # don't break [(]See: <xxxxx>[)] references

            # Table
            $text =~ s/<table=([^>]+)>/$self->BuildTable($1, $sourceFile)/ge;

            # Ditaa images
            $text =~ s/<ditaa([^>]+)>(.*?)<\/ditaa>/
                            $self->BuildDitaa($1, $2, $sourceFile, $imgSeqRef)/gse;

            # mscgen images
            $text =~ s/<mscgen([^>]+)>(.*?)<\/mscgen>/
                            $self->BuildMscgen($1, $2, $sourceFile, $imgSeqRef)/gse;

            # sdedit images
            $text =~ s/<sdedit([^>]+)>(.*?)<\/sdedit>/
                            $self->BuildSeqDiagEditor($1, $2, $sourceFile, $imgSeqRef)/gse;

            # Convert quotes to fancy quotes.
            $text =~ s/^\'/\\(oq/gm;                    # single-quote
            $text =~ s/([\ \(\[\{])\'/$1\\(oq/g;
            $text =~ s/\'/\\(cq/g;

            $text =~ s/^&quot;/\\(lq/gm;                # double-quote
            $text =~ s/([\ \(\[\{])&quot;/$1\\(lq/g;
            $text =~ s/&quot;/\\(rq/g;

            # Character markups
            $text =~ s/&lt;/\\(la/g;                    # left-angle
            $text =~ s/&gt;/\\(ra/g;                    # right-angle

            # We do full e-mail links anyway just so the obfuscation remains.
            $text =~ s/<email target=\"([^\"]*)\" name=\"([^\"]*)\">/
                            $self->BuildEMailLink($1, $2)/ge;

            # Copyright symbols.  Prevent conversion when part of (a), (b), (c) lists.
            $text =~ s/\(c\)/\\\(co/gi
                if ($text !~ /\(a\)/i);                 # \(co

            # Trademark/registered symbols.
            #   add leading; ASCII representations are simple text
            $text =~ s/\(tm\)/ \\\(tm/gi;               # \(tm
            $text =~ s/\(r\)/ \\\(rg/gi;                # \(rg

            # MAN markup's
            $text =~ s/&#92;/\\(rs/g;                   # \(rs
            $text =~ s/&amp;/\\*(Am/g;                  # \*(Am

            # Add double spaces too.
            $text = $self->AddDoubleSpaces($text);

            # Admonition's
            $text =~ s/<admon-([^>]+)>(.*?)<\/admon-([^>]+)>/
                            $self->BuildAdmonition($1, $2)/gse;

            # Headings
            $text =~ s/<h>/\e.Ss /g;                    # .Ss subheading "<heading>:"
            $text =~ s/<\/h>/:\e/g;

            # Subheadings
            $text =~ s/<h2>/\e.Ss /g;                   # .Ss subheading "<heading>,"
            $text =~ s/<\/h2>/,\e/g;

            # Paragraphs
            $text =~ s/<p>//g;
            $text =~ s/<\/p>/\e.Pp\e/g;                 # .Pp

            # Bold, italic, underline, strike-through
            $text =~ s/<b>/\\fB/g;                      # \fB
            $text =~ s/<\/b>/\\fR/g;                    # \fR

            $text =~ s/<i>/\\fI/g;                      # \fI
            $text =~ s/<\/i>/\\fR/g;                    # \fR

            $text =~ s/<u>/\\fI/g;                      # \fI
            $text =~ s/<\/u>/\\fR/g;                    # \fR

            $text =~ s/<d>/\\fI/g;                      # \fI
            $text =~ s/<\/d>/\\fR/g;                    # \fR

            # Indenting (Bullet, Ordered and Description lists)
            #   CBulletIndent, CDescIndent and COrderedIndent
            #
            $text =~ s/<(\w*)Indent(\d+)>//g;
            $text =~ s/<\/(\w*)Indent(\d+)>//g;

            # Bullet lists
            $text =~ s/<ul>/\e.Bl -bullet\e/g;          # .Bl -bullet
            $text =~ s/<\/ul>/\e.El\e.Pp\e/g;           # .El .Pp

            # Ordered (numeric) lists
            $text =~ s/<ol>/\e.Bl -enum\e/g;            # .Bl -enum
            $text =~ s/<ol type=([^>]+)>/\e.Bl -enum\e/g;
            $text =~ s/<\/ol>/\e.El\e.Pp\e/g;           # .El .Pp

            # Bullet/Order list items
            $text =~ s/<li>/\e.It\e/g;
            $text =~ s/<\/li>/\e/g;

            # Description Lists
            $text =~ s/<dl>/\e.Bl -tag -width "xxxxxxxx" -offset "xx"\e/g;
                                                        # .Bl -tag
            $text =~ s/<\/dl>/\e.El\e.Pp\e/g;           # .El .Pp

            $text =~ s/<de>/\e.It /g;
            $text =~ s/<\/de>/\e/g;

            if ($dlSymbolBehavior == ::ENUM_GLOBAL())
                {  $text =~ s/<ds>([^<]+)<\/ds>/$self->MakeDescriptionListSymbol(undef, $1)/ge;  }
            elsif ($dlSymbolBehavior == ::ENUM_UNDER_PARENT())
                {  $text =~ s/<ds>([^<]+)<\/ds>/$self->MakeDescriptionListSymbol($package, $1)/ge;  }
            else # ($dlSymbolBehavior == ::ENUM_UNDER_TYPE())
                {  $text =~ s/<ds>([^<]+)<\/ds>/$self->MakeDescriptionListSymbol($symbol, $1)/ge;  }

            sub MakeDescriptionListSymbol               # (package, text)
                {
                my ($self, $package, $text) = @_;

                $text = NaturalDocs::NDMarkup->RestoreAmpChars($text);
                my $symbol = NaturalDocs::SymbolString->FromText($text);

                if (defined $package)
                    {  $symbol = NaturalDocs::SymbolString->Join($package, $symbol);  };

            ##  return "<" . $text . ">";               # text or symbol??
                return "<" . $self->SymbolToMANSymbol($symbol) . ">";
                };

            $text =~ s/<dd>(.*?)<\/dd>/$self->MakeDescriptionListBody($1)/ge;

            sub MakeDescriptionListBody                 # text
                {
                my ($self, $text) = @_;

                $text =~ s/<br>/\e.Pp\e/g;
                return $text;
                }

            # Breaks
            $text =~ s/<br>/\e.br\e/g;                  # .br

            $output .= $text;
            };
        };

    return $output;
    };


#   Function: BuildURLLink
#       Creates a hyper-link to an external URL.
#
#   Parameters:
#       target          - The URL to link to.
#       name            - The label of the link.
#
#       Both are assumed to still have <NDMarkup> amp chars.
#
#   Returns:
#       The ink, complete with tags.
#
sub BuildURLLink        #(target, name)
    {
    my ($self, $target, $name) = @_;

    return "\e.Lk " . $target . "\e"
        if (!$name);
    return "\e.Lk " . $target . " \"" . $name . "\"\e";
    };


#   Function: BuildDitaa
#       Creates a ditaa image.
#
#   Parameters:
#       options         - User options for the ditaa processor.
#       img             - Image definition.
#       sourceFile      - Source image that owns the link.
#       imgSeqRef       - Reference to Image sequence number variable.
#
#   Returns:
#       The quoted ditaa definition.
#
sub BuildDitaa          #(options, img, sourceFile, imgSeqRef)
    {
    my ($self, $options, $img, $sourceFile, $imgSeqRef) = @_;

    $img = NaturalDocs::NDMarkup->RestoreAmpChars($img, 1);
    $img =~ s/\\/\\(rs/g;
    return
        "\e.Bd -literal -offset \"dt\"\e" .
            $img .
        "\e.Ed\e\.Pp\e";
    };


#   Function: BuildMscgen
#       Creates a mscgen image.
#
#   Parameters:
#       options         - User options for the mscgen processor.
#       img             - Image definition.
#       sourceFile      - Source image that owns the link.
#       imgSeqRef       - Reference to Image sequence number variable.
#
#   Returns:
#       The quoted mscgen definition.
#
sub BuildMscgen         #(options, img, sourceFile, imgSeqRef)
    {
    my ($self, $options, $img, $sourceFile, $imgSeqRef) = @_;

    $img = NaturalDocs::NDMarkup->RestoreAmpChars($img, 1);
    $img =~ s/\\/\\(rs/g;
    return
        "\e.Bd -literal -offset \"xx\"\e" .
            $img .
        "\e.Ed\e\.Pp\e";
    };


#   Function: BuildSeqDiagEditor
#       Creates a sdedit image.
#
#   Parameters:
#       options         - User options for the mscgen processor.
#       img             - Image definition.
#       sourceFile      - Source image that owns the link.
#       imgSeqRef       - Reference to Image sequence number variable.
#
#   Returns:
#       The quoted sdedit definition.
#
sub BuildSeqDiagEditor  #(options, img, sourceFile, imgSeqRef)
    {
    my ($self, $options, $img, $sourceFile, $imgSeqRef) = @_;

    $img = NaturalDocs::NDMarkup->RestoreAmpChars($img, 1);
    $img =~ s/\\/\\(rs/g;
    return
        "\e.Bd -literal -offset \"sq\"\e" .
            $img .
        "\e.Ed\e\.Pp\e";
    };


#   Function: BuildTable
#       Creates a MAN table
#
#   Parameters:
#       tableid         - Table object identifier.
#       sourceFile      - Source image that owns the table.
#       width           - Optional table width, passed during embedded table expansion.
#
#   Returns:
#       The MAN table.
#
sub BuildTable          #(tableid, sourceFile, [tablewidth])
    {
    my ($self, $tableid, $sourceFile, $tablewidth) = @_;

                                                        # retrieve table object
    my $table = NaturalDocs::Parser->Object($sourceFile, $tableid);

    return undef
        if (! $table);

    my ($rows, $cols) = ($table->Rows(), $table->Cols());

    return undef                                        # empty table?
        if ($rows <= 0 || $cols <= 0);

    $tablewidth = (74 - (($cols - 1) * 3))              # default table width
        if (!$tablewidth);

    my $embedded = $table->Embedded();
    my $output = "\n";

    my $tbl = NaturalDocs::Builder::ManTable->New();

    # Size columns
    for (my $col = 1; $col <= $cols; $col++)
        {
        my $cell = $table->Cell(1, $col);
        my $width = ($cell->Width() ? $cell->Width() : ($tablewidth / $cols));

        $tbl->SetWidth($col, int($tablewidth * ($width / 100.0)));
        }

    # Data
    for (my $row = 1; $row <= $rows; $row++)
        {
##FIXME my $ishead = 0;
        my @columns;

        for (my $col = 1; $col <= $cols; $col++)
            {                                           # each column
            my $cell = $table->Cell($row, $col);

            if (! defined $cell)
                {
                push @columns, undef;
                next;
                }

##FIXME     $ishead |= $cell->IsHead()
##              if (1 == $row);                         # head or data

##FIXME     my $spanning = $cell->Spanning();

            if (! $cell->IsNull())
                {
                my $content = $cell->ContentGet(1);
                if (defined $content && length($content))
                    {                                   # expand embedded tables
                    my $width = ($cell->Width() ? $cell->Width() : ($tablewidth / $cols));
                    $content =~ s/<table=([^>]+)>/$self->BuildTable($1, $sourceFile, $width)/ge;

                                                        # parse markups
                    push @columns, $self->TableContent($content);
                    }
                else
                    {
                    push @columns, '';
                    }
                }
            else
                {
                push @columns, '';
                }
            }

        $tbl->Add(@columns);
        }

    return $tbl->Export($tablewidth, $embedded ? 0 : 1, $embedded ? 0 : 1);
    }


sub TableContent        #(content)
    {
    my ($self, $content) = @_;

    # Links
    $content =~ s/<link target="[^\"]*" name="([^\"]*)" original="[^\"]*">/<$1>/g;
    $content =~ s/<url target="[^\"]*" name="([^\"]*)">/<$1>/g;
    $content =~ s/<img mode="[^\"]*" target="[^\"]*" original="([^\"]*)">/<br>$1<br>/g;

    # Embedded code elements
    $content =~ s/<code([^>]*)>(.*?)<\/code>/$self->ContentCode($2, 'code', $1)/gse;
    $content =~ s/<prefixcode([^>]*)>(.*?)<\/prefixcode>/$self->ContentCode($2, 'prefix', $1)/gse;
    $content =~ s/<quote([^>]*)>(.*?)<\/quote>/$self->ContentCode($2, 'quote', $1)/gse;

    # Bullet, ordered and description lists (un-nested)
    $content =~ s/<ul>(.*?)<\/ul>/$self->ContentList($1, 'ul')/gse;
    $content =~ s/<ol>(.*?)<\/ol>/$self->ContentList($1, 'ol')/gse;
    $content =~ s/<ol type=([^>]+)>(.*?)<\/ol>/$self->ContentList($2, 'ol', $1)/gse;
    $content =~ s/<dl>(.*?)<\/dl>/$self->ContentList($1, 'dl')/gse;

    return $content;
    };


sub ContentCode         #(body, type, options)
    {
    my ($self, $body, $type, $options) = @_;
    my @lines = split("<br>|[\n\e]", $body);

    $body = '';
    foreach (@lines)
        {
        $body .= '  ' . $_ . "<br>";
        }
    $body = $self->RestoreAmpChars($body);
    $body =~ s/\\/\\(rs/g;

    return $body;
    };


sub ContentList         #(body, type, [option])
    {
    my ($self, $body, $type, $options) = @_;

    if ($type eq 'ul')
        {                                               # bullet list
        $body =~ s/<li>(.*?)<\/li>/ o $1<br>/g;
        }
    elsif ($type eq 'ol')
        {                                               # ordered list
        my $ol = 0;
        sub OL {
            my $arg = shift @_;
            return " ".++$ol.". ".$arg."<br>";
            }
        $body =~ s/<li>(.*?)<\/li>/OL($1)/ge;
        }
    else    # 'dl'
        {                                               # description list
        ##TODO
        ##size description items.
        ##
        $body =~ s/<de>(.*?)<\/de>/ $1 - /g;
        $body =~ s/<dd>(.*?)<\/dd>/$1<br>/g;
        };

    $body = $self->RestoreAmpChars($body);
    $body =~ s/\\/\\(rs/g;

    return $body;
    };


#   Function: BuildEMailLink
#       Creates a MANDOC link to an e-mail address.
#
#   Parameters:
#       target          - The e-mail address.
#       name            - The label of the link.
#
#       Both are assumed to still have <NDMarkup> amp chars.
#
#   Returns:
#       The MAN e-mail link, complete with tags.
#
sub BuildEMailLink      #(target, name)
    {
    my ($self, $target, $name) = @_;

    $target = $self->RestoreAmpChars($target);

    return "\e.An $name $target\e"
        if ($name && $name ne $target);

    return "\e.Mt $target\e";
    };


#   Function: BuildImage
#       Builds the MANDOC for an image.
#
#   Parameters:
#       sourceFile - The source <FileName> this image appears in.
#       mode - Either "inline" or "link".
#       target - The target.
#       original - The original text.
#
#       All are assumed to still have <NDMarkup> amp chars.
#
#   Returns:
#       The result in MANDOCL.
#
sub BuildImage #(sourceFile, mode, target, original, imgSeqRef)
    {
    my ($self, $sourceFile, $mode, $target, $original, $imgSeqRef, $imageContentRef) = @_;

    my $targetNoAmp = $self->RestoreAmpChars($target);

    my $image = NaturalDocs::ImageReferenceTable->GetReferenceTarget($sourceFile, $targetNoAmp);

    if ($image)
        {
        my $extension = NaturalDocs::File->ExtensionOf($image);
        my $altImage = $image;

        $altImage =~ s/\.${extension}$/.ascii/;

        if (-f $altImage)
            {                                           # alternative ASCII image
            my $output = '';

            open(FH_ALTIMAGE, '<' . $altImage)
                or die "Couldn't open alt image <$altImage>\n";

            $output .=
                "\e.Bd -literal -offset \"am\"\e";
            while (<FH_ALTIMAGE>) {
                s/\s+$//g;
                $output .= $_." \e";
            }
            $output .=
                "\e.Ed\e\.Pp\e";

            close(FH_ALTIMAGE);
            return $output;
            }
        }

    if ($mode eq 'inline')
        {
        return
            "\e.Bd -literal -offset \"im\"\e" .
                $original .
            "\e.Ed\e\.Pp\e";
        }

    return $original;
    };


#   Function: BuildAdmonition
#       Builds the MAN for an image.
#
#   Parameters:
#       mode - Admonition mode; "Note", "Warning" etc
#       body - The body.
#
#   Returns:
#       The result in MANDOC markup.
#
sub BuildAdmonition     #(sourceFile, mode, body)
    {
    my ($self, $mode, $body) = @_;
    my $result = '';
    my $label;

    # Remove label from body.
    $body  =~ s/<ah>(.*)<\/ah>//g;
    $label = $1;

    # Format body
    $body  = $self->TableContent($body);
    $body  =~ s/<p>//g;

    my @parts = split(/<br>|<\/p>/, $body);
    my $cnt = scalar @parts;
    my @admon;
    foreach (@parts)
        {
        s/^\s+//g; s/[\s\e]+$//g;
        if (length($_))
            {
            push @admon, NaturalDocs::Builder::ManWrap::Format(60, $_);
            push @admon, ''
                if (--$cnt);
            }
        }

    # Export table
    #
    #  ------------------------------------------------
    #  Label:
    #   Body ........................................
    #   .............................................
    #  ------------------------------------------------
    #
    $result .=
        ".\" admonition\n" .
        ".TS\n" .
        "l l.\n" .
        " \t<b>${label}</b>\n" .
        " \t\\_\n";

    foreach (@admon)
        {
        $result .= " \t$_\n";
        }

    $result .=
        " \t\\_\n" .
        ".TE\n";

    return $result;
    }


###############################################################################
#   Group: Utility Functions

#   Function: StringToMAN
#       Converts a text string to MANDOC.  Does not apply paragraph tags or accept formatting tags.
#
#   Parameters:
#       string          - The string to convert.
#       addHiddenBreaks - Whether to add hidden breaks to the string.  You can use <ADD_HIDDEN_BREAKS>
#                           for this parameter if you want to make the calling code clearer.
#
#   Returns:
#       The string in MANDOC.
#
sub StringToMAN         #(string)
    {
    my ($self, $string, $addHiddenBreaks) = @_;

    # special characters
    $string =~ s/</\\(la/g;                             # left-angle
    $string =~ s/>/\\(ra/g;                             # right-angle
    $string =~ s/\\/\\(rs/g;                            # backslashes

    # fancy quotes
    $string =~ s/^\'/\\(oq/gm;                          # single-quote
    $string =~ s/([\ \(\[\{])\'/$1\\(oq/g;
    $string =~ s/\'/\\(cq/g;

    $string =~ s/^\"/\\(lq/gm;                          # double-quote
    $string =~ s/([\ \(\[\{])\"/$1\\(lq/g;
    $string =~ s/\"/\\(rq/g;

    return $string;
    };


#   Function: SymbolToMANSymbol
#       Converts a <SymbolString> to a MAN symbol, meaning one that is safe to include in anchor and
#       link tags.  You don't need to pass the result to <ConvertAmpChars()>.
#
sub SymbolToMANSymbol #(symbol)
    {
    my ($self, $symbol) = @_;

    my @identifiers = NaturalDocs::SymbolString->IdentifiersOf($symbol);
    my $htmlSymbol = join('.', @identifiers);

    return $htmlSymbol;
    };


#   Function: AddDoubleSpaces
#       Adds second spaces after the appropriate punctuation with &nbsp; so they show up in MAN.  They don't occur
#       if there isn't at least one space after the punctuation, so things like class.member notation won't be affected.
#
#   Parameters:
#       text            - The text to convert.
#
#   Returns:
#       The text with double spaces as necessary.
#
sub AddDoubleSpaces     #(text)
    {
    my ($self, $text) = @_;

    # Question marks and exclamation points get double spaces unless followed by a lowercase letter.

    $text =~ s/  ([^\ \t\r\n] [\!\?])                   # Must appear after a non-whitespace character to apply.

                      (&quot;|&[lr][sd]quo;|[\'\"\]\}\)]?)  # Tolerate closing quotes, parenthesis, etc.
                      ((?:<[^>]+>)*)                        # Tolerate tags

                      \                                 # The space
                      (?![a-z])                         # Not followed by a lowercase character.

                 /$1$2$3\\~\ /gx;                       # \~,   pad-able non-breaking space

    # Periods get double spaces if it's not followed by a lowercase letter.  However, if it's followed by a capital letter and the
    # preceding word is in the list of acceptable abbreviations, it won't get the double space.  Yes, I do realize I am seriously
    # over-engineering this.

    $text =~ s/  ([^\ \t\r\n]+)                         # The word prior to the period.

                      \.

                      (&quot;|&[lr][sd]quo;|[\'\"\]\}\)]?)  # Tolerate closing quotes, parenthesis, etc.
                      ((?:<[^>]+>)*)                        # Tolerate tags

                      \                                 # The space
                      ([^a-z])                          # The next character, if it's not a lowercase letter.

                  /$1 . '.' . $2 . $3 . MaybeExpand($1, $4) . $4/gex;

    sub MaybeExpand     #(leadWord, nextLetter)
        {
        my ($leadWord, $nextLetter) = @_;

        if ($nextLetter =~ /^[A-Z]$/ && exists $abbreviations{ lc($leadWord) } )
            { return ' '; }
        else
            { return '\~ '; };                          # \~,    pad-able non-breaking space
        };

    return $text;
    };


#   Function: ConvertAmpChars
#       Converts certain characters to their MAN character equivalents.
#
#   Parameters:
#       text            - The text to convert.
#
#   Returns:
#       The converted text.
#
sub ConvertAmpChars     #(text)
    {
    my ($self, $text) = @_;

    $text =~ s/&#92;/\\(rs/g;                           # \(rs,  backslashes

    $text =~ s/&amp;/\\*(Am/g;                          # \*(Am, ampersand

    $text =~ s/\"/\\(dq;/g;                             # \(dq,  double-quote
    $text =~ s/&quot;/\\(dq/g;

    $text =~ s/</\\(la/g;                               # \(la,  left-angle
    $text =~ s/&lt;/\\(la/g;

    $text =~ s/>/\\(ra/g;                               # \(ra,  right-angle
    $text =~ s/&gt;/\\(ra/g;

    return $text;
    };


#   Function: RestoreAmpChars
#       Restores all amp characters to their original state.  This works with both <NDMarkup> amp chars and fancy quotes.
#
#   Parameters:
#       text            - The text to convert.
#
#   Returns:
#       The converted text.
#
sub RestoreAmpChars     #(text)
    {
    my ($self, $text) = @_;
                                                        # &#92;  &quot, &gt, &lt and &amp
    $text = NaturalDocs::NDMarkup->RestoreAmpChars($text);

    $text =~ s/\\\(oq/\'/g;                             # \(oq,  single quote
    $text =~ s/\\\(cq/\'/g;

    $text =~ s/\\\(lq/\"/g;                             # \(lq,  double quote
    $text =~ s/\\\(rq/\"/g;

    return $text;
    };


#   Function: CompressWS
#       Compress repeated white-space within the specified text.
#
#   Parameters:
#       text            - The text to be compressed.
#
#   Returns:
#       The converted text.
#
sub CompressWS          #(text)
    {
    my ($self, $text) = @_;

    $text =~ s/^\s+//g;
    $text =~ s/\s+$//g;
    $text =~ s/\s+/ /g;

    return $text;
    }


#   Function: MakeRelativeURL
#       Returns a relative path between two files in the output tree and returns it in URL format.
#
#   Parameters:
#       baseFile        - The base <FileName> in local format, *not* in URL format.
#       targetFile      - The target <FileName> of the link in local format, *not* in URL format.
#       baseHasFileName - Whether baseFile has a file name attached or is just a path.
#
#   Returns:
#       The relative URL to the target.
#
sub MakeRelativeURL     #(FileName baseFile, FileName targetFile, bool baseHasFileName) -> string relativeURL
    {
    my ($self, $baseFile, $targetFile, $baseHasFileName) = @_;

    if ($baseHasFileName)
        {  $baseFile = NaturalDocs::File->NoFileName($baseFile)  };

    my $relativePath = NaturalDocs::File->MakeRelativePath($baseFile, $targetFile);

    return $self->ConvertAmpChars( NaturalDocs::File->ConvertToURL($relativePath) );
    };


###############################################################################
#   Group: Section Functions

#   Function: BuildTitle
#       Builds and returns the MAN page title of a file.
#
#   Parameters:
#       sourceFile      - The source <FileName> to build the title of.
#
#   Returns:
#       The source file's title in MANDOC.
#
sub BuildTitle          #(sourceFile)
    {
    my ($self, $sourceFile) = @_;

    # If we have a menu title, the page title is [menu title] - [file title].  Otherwise it is just [file title].

    my $title = NaturalDocs::Project->DefaultMenuTitleOf($sourceFile);

    my $menuTitle = NaturalDocs::Menu->Title();
    if (defined $menuTitle && $menuTitle ne $title)
        {  $title .= ' - ' . $menuTitle;  };

    $title = $self->StringToMAN($title);

    return $title;
    };


###############################################################################
#   Group: Index Functions


###############################################################################
#   Group: File Functions

#   Function: OutputFileOf
#       Returns the output file name of the source file.  Will be undef if it is not a file from a valid input directory.
#
sub OutputFileOf        #(sourceFile)
    {
    my ($self, $sourceFile, $noext) = @_;

    my ($inputDirectory, $relativeSourceFile) = NaturalDocs::Settings->SplitFromInputDirectory($sourceFile);
    if (!defined $inputDirectory)
        {  return undef;  };

    my $outputDirectory = NaturalDocs::Settings->OutputDirectoryOf($self);
    my $inputDirectoryName = NaturalDocs::Settings->InputDirectoryNameOf($inputDirectory);

    # We need to change any extensions to dashes because Apache will think file.pl.man is a script.
    # We also need to add a dash if the file doesn't have an extension so there'd be no conflicts with index.man,
    # FunctionIndex.man, etc.

    if (!($relativeSourceFile =~ tr/./-/))
        {  $relativeSourceFile .= '-';  };

    if (!defined $noext)                                # image
        {
        $relativeSourceFile =~ tr/ &?(){};/_/;
        $relativeSourceFile .= '.mandoc';
        }

    return NaturalDocs::File->JoinPaths($outputDirectory, $relativeSourceFile);
    };


#   Function: OutputImageOf
#       Returns the output image file name of the source image file.  Will be undef if it is not a file from a
#       valid input directory.
#
sub OutputImageOf       #(sourceImageFile)
    {
    my ($self, $sourceImageFile) = @_;

    my $outputDirectory = NaturalDocs::Settings->OutputDirectoryOf($self);
    my $topLevelDirectory;

    my ($inputDirectory, $relativeImageFile) = NaturalDocs::Settings->SplitFromInputDirectory($sourceImageFile);

    if (defined $inputDirectory)
        {
        my $inputDirectoryName = NaturalDocs::Settings->InputDirectoryNameOf($inputDirectory);
        $topLevelDirectory = 'files' . ($inputDirectoryName != 1 ? $inputDirectoryName : '');
        }
    else
        {
        ($inputDirectory, $relativeImageFile) = NaturalDocs::Settings->SplitFromImageDirectory($sourceImageFile);

        if (!defined $inputDirectory)
            {  return undef;  };

        my $inputDirectoryName = NaturalDocs::Settings->ImageDirectoryNameOf($inputDirectory);
        $topLevelDirectory = 'images' . ($inputDirectoryName != 1 ? $inputDirectoryName : '');
        }


    $outputDirectory = NaturalDocs::File->JoinPaths($outputDirectory, $topLevelDirectory, 1);

    $relativeImageFile =~ tr/ /_/;

    return NaturalDocs::File->JoinPaths($outputDirectory, $relativeImageFile);
    };


###############################################################################
#   Group: Support Functions

1;

#end
